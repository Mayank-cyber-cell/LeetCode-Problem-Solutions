MOD = 10**9 + 7

class Solution:
    def magicalSum(self, m, k, nums):
        n = len(nums)
        if k < 0 or k > m:
            return 0
        if n == 0:
            return 0

        # Precompute factorials and inverse factorials up to m
        fact = [1] * (m + 1)
        for i in range(1, m + 1):
            fact[i] = fact[i-1] * i % MOD
        invfact = [1] * (m + 1)
        invfact[m] = pow(fact[m], MOD-2, MOD)
        for i in range(m, 0, -1):
            invfact[i-1] = invfact[i] * i % MOD

        # Precompute, for each value v = nums[i], coeffs coeff[c] = v^c / c! (mod MOD), for c=0..m
        pow_coeff = []
        for v in nums:
            row = [1] * (m + 1)
            # v^c
            for c in range(1, m + 1):
                row[c] = row[c-1] * v % MOD
            # multiply by invfact[c]
            for c in range(0, m + 1):
                row[c] = row[c] * invfact[c] % MOD
            pow_coeff.append(row)

        # DP arrays: dp[carry][ones][t] -> modular weight
        # We'll keep them as flat 3D lists for speed: size (m+1)*(m+1)*(m+1)
        size = m + 1
        def make_dp():
            return [0] * (size * size * size)

        def idx(carry, ones, t):
            # carry in [0..m], ones in [0..m], t in [0..m]
            return (carry * size + ones) * size + t

        dp = make_dp()
        dp[idx(0,0,0)] = 1  # start

        # iterate each index (bit position)
        for i in range(n):
            coeffs = pow_coeff[i]
            dp2 = make_dp()
            # iterate existing states
            # for speed, we iterate over t first as it's most constrained
            for carry in range(0, m+1):
                for ones in range(0, m+1):
                    base_off = (carry * size + ones) * size
                    for t in range(0, m+1):
                        val = dp[base_off + t]
                        if not val:
                            continue
                        # choose c occurrences of this index (0..m-t)
                        maxc = m - t
                        # localize val to avoid repeated global lookups
                        vval = val
                        for c in range(0, maxc+1):
                            newt = t + c
                            s = carry + c
                            bit = s & 1
                            newcarry = s >> 1
                            newones = ones + bit
                            if newones > m:
                                # no need to proceed further for higher c as newones increases slowly, but safe-check
                                pass
                            # multiply by coeffs[c] (v^c / c!)
                            add = vval * coeffs[c] % MOD
                            dp2[idx(newcarry, newones, newt)] = (dp2[idx(newcarry, newones, newt)] + add) % MOD
            dp = dp2

        # after processing all indices, we need total t == m
        ans = 0
        for carry in range(0, m+1):
            popc = bin(carry).count("1")
            for ones in range(0, m+1):
                if ones + popc == k:
                    val = dp[idx(carry, ones, m)]
                    if val:
                        ans = (ans + val) % MOD

        # multiply by m! to account for ordering (multinomial factor)
        ans = ans * fact[m] % MOD
        return ans
